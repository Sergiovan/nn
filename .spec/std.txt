# compiler
$if <expression or compiler variable>
 - Only compiles if <> is true/is defined
$major <number>
 - Only compiles if <> is bigger or equal to the current major version
$minor <number>
 - Only compiles if <> is bigger or equal to the current minor version
$assert <expression>
 - Compile-time assertion
$$version
 - Version of nn, as a numeric timestamp
$$version_complex
 - Textual version of nn of the form "major.minor.build". Major is decided upon, minor is based on commits since major, build is self explanatory
$$version_major
 - Numeric major version
$$version_minor
 - Numeric minor version
$$version_build
 - Numeric build
$$version_compiler
 - Version of the compiler, as a numeric timestamp
$$version_compiler_complex
 - Textual version of the compiler, at the discretion of the compiler maker
 
 
# nn
const int EXIT_NORMAL=0
const int EXIT_ERROR=1

void abort()
void exit(int ret=0)

# assert
void assert(bool expression, string message="")


# io

int:sig print(string... text)
string:sig scan(char delim='\n')

file:sig open(string path, byte flags)
byte[]:sig read_bytes(file, unsigned long amount)
string:sig read_str(file, unsigned long length)
int:sig write(file, byte[] bytes)
int:sig write(file, byte* bytes, unsigned long amount)
int:sig write(file, char[] chars)
int:sig write(file, char* chars, unsigned long amount)
sig set_pos(file, long pos, byte flags)
sig close(file)


struct file {
    // Stuff needed for files
}

#os

sig sleep(double millis)
sig system(string command)


# stringutils

string:sig format(string format, ...)
sig unformat(string format, ...)
int:sig length(string)
string:sig to_str(byte)
string:sig to_str(short)
string:sig to_str(int)
string:sig to_str(long)
string:sig to_str(float)
string:sig to_str(double)
string:sig to_str(byte[])
byte[]:sig to_bytes(string)
byte[]:sig to_bytes(char)
char:sig at(string, unsigned long index)

#numutils

const byte ZERO=0

const byte MAX_BYTE=255
const byte MAX_SIGNED_BYTE=127
const byte MIN_SIGNED_BYTE=-128

const short MAX_SHORT=32767
const short MIN_SHORT=-32768
const short MAX_UNSIGNED_SHORT=65535

const int MAX_INT=2147483647
const int MIN_INT=-2147483648
const int MAX_UNSIGNED_INT=4294967295

const long MAX_LONG=9223372036854775807
const long MIN_LONG=-9223372036854775808
const long MAX_UNSIGNED_LONG=18446744073709551615

// Float constants go here

#math

double:sig cos(double x)
double:sig sin(double x)
double:sig tan(double x)
double:sig tan2(double y, double x)

double:sig sqrt(double x)

long max(long x, long y)
long min(long x, long y)
double max(double x, double y)
double min(double x, double y)
long clamp(long x, long low, long high)
double clamp(double x, double low, double high)

#algorithm

// Reserved 

#random

double:sig random() // [0.0-1.0)
generation:sig make_generator(...) // TBD
sig seed(generator, ...) // TBD
int:sig get_int(generator, int min = 0, int max = numutils.MAX_INT)
double:sig get_random(generator, double min = 0.0, double max = 1.0)


struct generator {
    // Stuff needed for random generation
}