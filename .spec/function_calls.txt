Everything done by caller, basically.

0. r14:r15 should not contain anything that can't be replaced.
2. Load parameters left-to-right, first parameter is at the bottom.
3. Load stack, usually empty. In case of closures or coroutines, things may be added here. When calling a function normally, this is known at compile time. If not, closure objects have the required information. This can be a no-op.
4. Call function. This also automatically puts the frame pointer and return address at the very bottom of the stack. This also means the parameters are below the frame pointer.
5. Function happens, who knows what magical things are achieved.
6. Returns always in r14:r15. If data is bigger than 16 bytes, r14 is a pointer to the data (stored above the stack) and r15 is the size of the data. The data is formatted as if it were a struct of the return types.
6. Stack is "cleaned up" by callee. Once again, this is automatically done for normal functions, but requires some help with closures. Might be a no-op.
7. RET instruction pops return address and frame pointer from stack.
8. Control is back to caller. Stack is as it was before 0, returns are in r14:r15.