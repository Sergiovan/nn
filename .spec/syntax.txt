letter = [a-zA-Z]
digit  = [0-9]
whitespace = [ \n\t]
symbols = [+-*/%#~&@|^!?:;<>,.'"[]{}()=\`]
underscore = _
dollar = $
other = !symbols & !whitespace & !dollar & !letter & !digit & !underscore
identifier_legal = underscore | letter | other
any = ["\\"] , letter | digit | whitespace | symbols | underscore | dollar | other

tvoid        = "void"
tbyte        = "byte"
tchar        = "char"
tshort       = "short"
tint         = "int"
tlong        = "long"
tsig         = "sig"
tfloat       = "float"
tdouble      = "double"
tbool        = "bool"
tstruct      = "struct"
tunion       = "union"
tenum        = "enum"
tstring      = "string"
tfunction    = "fun"
tlet         = "let"

kwtype       = tvoid | tbyte | tchar | tshort | tint | tlong | tsig | tfloat | tdouble | tbool | tstruct | tunion | tenum | tstring | tfunction | tlet

qconst       = "const"
qvolatile    = "volatile"
qpointer     = "*"
qupointer    = "*!"
qwpointer    = "*?"
qspointer    = "*+"

kwqualifier  = qconst | qvolatile
spointer     = qpointer | qupointer | qwpointer | qspointer 

cif          = "if"
celse        = "else"
cfor         = "for"
cwhile       = "while"
cdo          = "do"
cswitch      = "switch"
creturn      = "return"
craise       = "raise"
cbreak       = "break"
ccontinue    = "continue"
cleave       = "leave"
cgoto        = "goto"
clabel       = "label"
cdefer       = "defer"

kwcontrol    = cif | celse | cfor | cwhile | cdo | cswitch | creturn | craise | cbreak | ccontinue | cleave | cgoto | clabel | cdefer

kwtrue       = "true"
kwfalse      = "false"
kwnull       = "null"
kwimport     = "import"
kwusing      = "using"
kwnamespace  = "namespace"
kwcase       = "case"
kwas		 = "as"
kwnew 		 = "new"
kwdelete	 = "delete"

kwbool       = kwtrue | kwfalse
kwmemory 	 = kwnew | kwdelete
kwother      = kwnull | kwimport | kwusing | kwnamespace | kwcase | kwas

rtry 	     = "try"
rcatch		 = "catch"
rand         = "and"
ror          = "or"

kwreserved   = rtry | rcatch | rand | ror

snothing	 = "---"
tokenspecial = snothing 	 

opinc        = "++"
opdec        = "--"

opadd        = "+"
opsub        = "-"
opmul        = "*"
oppow        = "**"
opdiv        = "/"
opmod        = "%"

opaddress    = "*"
opat         = "@"

opnot        = "!"
opand        = "&"
opor         = "|"
opxor        = "^"

oplnot       = "!!"
opland       = "&&"
oplor        = "||"
oplxor       = "^^"

opaccess     = "."
opconcat     = ".."
opspread     = "..."

opttond     = "?"
optthen     = ":"

opbitset     = "@|"
opbitclear   = "@&"
opbitcheck   = "@?"
opbittoggle  = "@^"

opbitshiftl  = "<<"
opbitshiftr  = ">>"
oprotatel    = "<<<"
oprotater    = ">>>"

opequals     = "=="
opnequals    = "!="
opgt         = ">"
opgeqt       = ">="
oplt         = "<"
opleqt       = "<="

opassign     = "="
opaddassign  = "+="
opdecassign  = "-="
opmulassign  = "*="
oppowassign  = "**="
opdivassign  = "/="
opandassign  = "&="
oporassign   = "|="
opxorassign  = "^="
opshiftlassign    = "<<="
opshiftrassign    = ">>="
oprotatelassign   = "<<<="
oprotatearssign   = ">>>="
opconcatassign    = "..="
opbitsetassign    = "@|="
opbitclearassign  = "@&="
opbittoggleassign = "@^="

unop     = opinc | opdec | opsub | opaddress | opat | opnot | oplnot | opspread
preunop  = opinc | opdec | opsub | opaddress | opat | opnot | oplnot
postunop = opinc | opdec | opspread
binop    = opadd | opsub | opmul | oppow | opdiv | opmod | opand | opor | opxor | opland | oplor | oplxor | opaccess | opconcat | opbitset | opbitclear | opbitcheck | opbittoggle | opbitshiftl | opbitshiftr | oprotatel | oprotater | opequals | opnequals | opgt | opgeqt | oplt | opleqt
ternop   = optcond | optthen
assop    = opassign | opaddassign | opdecassign | opmulassign | oppowassign | opdivassign | oporassign | opxorassign | opshiftlassign | opshiftrassign | oprotatelassign | oprotaterassign | opconcatassign | opbitsetassign | opbitclearassign | opbittoggleassign 

operator = unop | binop | assop

iden   = identifier_legal , {identifier_legal | digit}
compileriden = dollar, identifier_legal, {identifier_legal | digit}

number = digit , {digit} , ["." , digit , {digit}]
b2number  = ("0b" | "0B") , ([01]) , {[01]}
b8number  = ("0o" | "0O") , ([0-7]) , {[0-7]}
b16number = ("0x" | "0X") , ([0-9a-fA-F]) ,{[0-9a-fA-F]})
banumber  = digit , {digit}, ("l" , "L") , (letter | digit) , {letter | digit}
string = "\"" , {any} , "\""
char   = "'" , any , "'"
array  = "[", [expression, {",", expression}, [","]], "]"
struct_lit = "{", [(expression, {",", expression} | iden, "=", expression, {",", iden, "=", expression}), ","], "}"

literal = number | b2number | b8number | b16number | banumber | string | char | array | struct_lit

compileropts = dollar, "[", {compileriden, {",", compileriden}}, "]"

scope = "{", statements, "}", [compileropts]

statements = {statement}
statement = [compileriden],
	ifstmt | 
	forstmt | 
	whilestmt | 
	switchstmt |
	returnstmt | 
	raisestmt | 
	gotostmt | 
	labelstmt |
	deferstmt |
	breakstmt |
	continuestmt | 
	leavestmt | 
	usingstmt |
	namespacestmt |
	declstmt | 
	assstmt |
	expressionstmt |
	scope

ifstmt = ifsemi , ifstmt'
ifsemi =  cif , (expression | {deoa, ";", })
ifstmt' = cdo , statement | scope , [elsestmt]
elsestmt = celse , scope | celse , ifsemi , scope , [elsestmt]

forstmt = cfor , forcond , forstmt'
forcond = 
	deoa , (";", [expression], ";", [expressionorassignment], {";", [expressionorassignment]} | "," , expression, ["," , expression]) | 
	";" , [expression], ";" [expressionorassignment], {";", [expressionorassignment]} | 
	(type | tlet), iden, optthen, expression
forstmt' = scope | cdo , statement

whilestmt = whilesemi , whilestmt'
whilesemi = cwhile , expression , {";" , expression}
whilestmt' = cdo , statement | scope

switchstmt = cswitch , expression , {";" , expression} , switchscope
switchscope = "{" , {casestmt} , "}"
casestmt = ((kwcase , expression , {"," , expression}) | celse) , (ccontinue | scope | cdo, statement)

returnstmt = creturn, expression, {",", expression}, ";"

raisestmt = craisem, expression, {",", expression}, ";"

gotostmt = cgoto, iden, ";"

labelstmt = clabel, iden, ";"

deferstmt = cdefer, expression, ";"

breakstmt = cbreak, ";"

continuestmt = ccontinue, ";"

leavestmt = cleave, ";"

usingstmt = kwusing, iden , {opaccess, iden} , [kwas, iden] ";"

namespacestmt = kwnamespace, iden, {opaccess, iden} , scope

type = {kwqualifier}, (tbyte | tchar | tshort | tint | tlong | tsig | tfloat | tdouble | tbool | tstring | functype | iden), [spointer], {{kwqualifier}, spointer}, {"[", expression, "]"}{"[", "]"}
functype = "tfunction", ["<", type, {":", type}, "(", type, {",", type}, ")", ">"]

declstmt = 	tvoid, functiondecl | 
			tlet, funcorvardecl | 
			type, (":", type, {":", type}, functiondecl | funcorvardecl) | 
			tstruct, iden, (structscope | ";") | 
			tunion, iden, (unionscope | ";") |
			tenum, iden, (enumscope | ";")

(* Ambiguity resolved by symbol table *)
funcorvardecl = iden, (vardeclnoass, ";" | assignmentval, vardeclnoass, ";" | functionparams, (scope | ";"))
functiondecl = iden, functionparams, (scope | ";")
functionparams = "(", [functionparam, {",", functionparam}] ")"
functionparam = type, [iden, ["=", expression]],

functionval = (tvoid | type, {":", type}), [iden], scope

(* Ambiguity resolved by symbol table *)
vardecl = iden, vardecl'
vardecl' = (vardeclnoass | assignmentval, vardeclnoass))
vardeclnoass = "~", [type], vardecl | ",", vardecl

vardef	= type, iden, {",", [type], iden}, opequals, (expression | nosthing | functionval), {",", (expression | snothing | functionval)}

structscope = "{", structscopeinner, "}", [compileropts]
structscopeinner = {usingstmt | declstmt}

unionscope = "{", unionscopeinner, "}", [compileropts]
unionscopeinner = {usingstmt | declstmt}

enumscope = "{", iden, {",", iden}, [","], "}", [compileropts]

assstmt = assignment, ";"
assignment 		  = iden, {",", iden}, assop, (expression | functionval), {",", (expression | functionval)}
assignmentval     = "=", (expression | snothing | functionval), {",", (expression | snothing | functionval)}

expressionstmt = expression , ";"
expression = e16

e16   = e15, [e16']
e16'  = optcond, e16, optthen, e16

e15   = e14, {e15'}
e15'  = (opequals | opnequals),  e14

e14   = e13, {e14'}
e14'  = (oplt | opleqt | opgt | opgeqt), e13

e13   = e12, {e13'}
e13'  = oplxor, e12

e12   = e11, {e12'}
e12'  = oplor, e11

e11   = e10, {e11'}
e11'  = opland, e10

e10   = e9, {e10'}
e10'  = opxor, e9

e9    = e8, {e9'}
e9'   = opor, e8

e8    = e7, {e8'}
e8'   = opand, e7

e7    = e6, {e7'}
e7'	  = (opbitset | opbitclear | opbitcheck | opbittoggle), e6

e6    = e5, {e6'}
e6'	  = (opbitshiftl | opbitshiftr | oprotatel | oprotater), e5

e5    = e4, {e5'}
e5'	  = (opadd | opsub | opconcat), e4

e4    = e3, {e4'}
e4'	  = (opmul | opdiv | opmod), e3

e3    = e2, [e3']
e3'   = (oppow | opconcat), e3

e2    = (opinc | opdec | opadd | opsub | opnot | oplnot | "<", type, ">" | opat | opaddress) e2 | e1.5

e1.5  = e1, {e1.5'}
e1.5' = (opspread)

e1    = ee, {e1'}
e1'	  = (opinc | opdec | "(", [argument, {",", argument}], ")" | "[", expression, "]" | opaccess, iden), {opinc | opdec | "(", [argument, {",", argument}], ")" | "[", expression, "]" | opaccess, iden}, ee

ee 	  = "(", (expression | functionval), ")" | literal | iden

argument  = (expression | snothing | functionval) | iden, "=", (expression | functionval) (* LL(2) lookahead for = *)
expressionorassignment = expression | assignment (* LL(2), lookahead for , or = *)
deoa = vardef | expression | assignment (* LL(2), lookeahead for , or = *)

------------- Operator precedence --------------
1: a++ a-- a() a[] a.b 
1.5: a...
2: ++a --a +a -a !a !!a <type>a @a #a
3: a**b a..b
4: a*b a/b a%b
5: a+b a-b
6: a<<b a>>b a<<<b a>>>b
7: a@|b a@&b a@?b a@^b
8: a&b
9: a|b 
10: a^b 
11: a&&b 
12: a||b 
13: a^^b 
14: a<b a<=b a>b a>=b
15: a==b a!=b 