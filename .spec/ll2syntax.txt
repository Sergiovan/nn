letter = [a-zA-Z]
digit  = [0-9]
whitespace = [ \n\t]
symbols = [+-*/%#~&@|^!?:;<>,.'"[]{}()=\`]
underscore = _
dollar = $
other = !symbols & !whitespace & !dollar & !letter & !digit & !underscore
identifier_legal = underscore | letter | other
any = ["\\"] , letter | digit | whitespace | symbols | underscore | dollar | other

tvoid        = "void"
tbyte        = "byte"
tchar        = "char"
tshort       = "short"
tint         = "int"
tlong        = "long"
tsig         = "sig"
tfloat       = "float"
tdouble      = "double"
tbool        = "bool"
tstruct      = "struct"
tunion       = "union"
tenum        = "enum"
tstring      = "string"
tfunction    = "fun"
tlet         = "let"

kwtype       = tvoid | tbyte | tchar | tshort | tint | tlong | tsig | tfloat | tdouble | tbool | tstruct | tunion | tenum | tstring | tfunction | tlet

qconst       = "const"
qvolatile    = "volatile"
qsigned 	 = "signed"
qunsigned    = "unsigned"
qpointer     = "*"
qupointer    = "*!"
qwpointer    = "*?"
qspointer    = "*+"

kwqualifier  = qconst | qvolatile
kwsign		 = qsigned | qunsigned
spointer     = qpointer | qupointer | qwpointer | qspointer 

cif          = "if"
celse        = "else"
cfor         = "for"
cwhile       = "while"
cdo          = "do"
cswitch      = "switch"
creturn      = "return"
craise       = "raise"
cbreak       = "break"
ccontinue    = "continue"
cleave       = "leave"
cgoto        = "goto"
clabel       = "label"
cdefer       = "defer"

kwcontrol    = cif | celse | cfor | cwhile | cdo | cswitch | creturn | craise | cbreak | ccontinue | cleave | cgoto | clabel | cdefer

kwtrue       = "true"
kwfalse      = "false"
kwnull       = "null"
kwimport     = "import"
kwusing      = "using"
kwnamespace  = "namespace"
kwcase       = "case"
kwas		 = "as"
kwnew 		 = "new"
kwdelete	 = "delete"

kwbool       = kwtrue | kwfalse
kwmemory 	 = kwnew | kwdelete
kwother      = kwnull | kwimport | kwusing | kwnamespace | kwcase | kwas

rtry 	     = "try"
rcatch		 = "catch"
rand         = "and"
ror          = "or"

kwreserved   = rtry | rcatch | rand | ror

snothing	 = "---"
tokenspecial = snothing 	 

opinc        = "++"
opdec        = "--"

opadd        = "+"
opsub        = "-"
opmul        = "*"
oppow        = "**"
opdiv        = "/"
opmod        = "%"

opaddress    = "*"
opat         = "@"

opnot        = "!"
opand        = "&"
opor         = "|"
opxor        = "^"

oplnot       = "!!"
opland       = "&&"
oplor        = "||"
oplxor       = "^^"

opaccess     = "."
opconcat     = ".."
opspread     = "..."

opttond     = "?"
optthen     = ":"

opbitset     = "@|"
opbitclear   = "@&"
opbitcheck   = "@?"
opbittoggle  = "@^"

opbitshiftl  = "<<"
opbitshiftr  = ">>"
oprotatel    = "<<<"
oprotater    = ">>>"

opequals     = "=="
opnequals    = "!="
opgt         = ">"
opgeqt       = ">="
oplt         = "<"
opleqt       = "<="

opassign     = "="
opaddassign  = "+="
opdecassign  = "-="
opmulassign  = "*="
oppowassign  = "**="
opdivassign  = "/="
opandassign  = "&="
oporassign   = "|="
opxorassign  = "^="
opshiftlassign    = "<<="
opshiftrassign    = ">>="
oprotatelassign   = "<<<="
oprotatearssign   = ">>>="
opconcatassign    = "..="
opbitsetassign    = "@|="
opbitclearassign  = "@&="
opbittoggleassign = "@^="

stmtend = ";"
vardeclend = "~"
comma = ","
oparen = "("
cparen = ")"
obracket = "["
cbracket = "]"
obrace = "{"
cbrace = "}"
numberseparator = "."
quote = "'"
dquote = "\""
othan = "<"
cthan = ">"

unop     = opinc | opdec | opsub | opaddress | opat | opnot | oplnot | opspread
preunop  = opinc | opdec | opsub | opaddress | opat | opnot | oplnot
postunop = opinc | opdec | opspread
binop    = opadd | opsub | opmul | oppow | opdiv | opmod | opand | opor | opxor | opland | oplor | oplxor | opaccess | opconcat | opbitset | opbitclear | opbitcheck | opbittoggle | opbitshiftl | opbitshiftr | oprotatel | oprotater | opequals | opnequals | opgt | opgeqt | oplt | opleqt
ternop   = optcond | optthen
assop    = opassign | opaddassign | opdecassign | opmulassign | oppowassign | opdivassign | oporassign | opxorassign | opshiftlassign | opshiftrassign | oprotatelassign | oprotaterassign | opconcatassign | opbitsetassign | opbitclearassign | opbittoggleassign 

operator = unop | binop | assop

iden   = identifier_legal , {identifier_legal | digit}
compileriden = dollar, identifier_legal, {identifier_legal | digit}

number = digit , {digit} , [numberseparator , digit , {digit}]
b2number  = ("0b" | "0B") , ([01]) , {[01]}
b8number  = ("0o" | "0O") , ([0-7]) , {[0-7]}
b16number = ("0x" | "0X") , ([0-9a-fA-F]) ,{[0-9a-fA-F]})
banumber  = digit , {digit}, ("l" , "L") , (letter | digit) , {letter | digit}
string = dquote , {any} , dquote
char   = quote, any, quote
array  = obracket, [expression, {comma, expression}, [comma]], cbracket
struct_lit = obrace, [(expression, {comma, expression} | iden, assop, expression, {comma, iden, assop, expression}), comma], cbrace

literal = number | b2number | b8number | b16number | banumber | string | char | array | struct_lit

program = {usingstmt | namespacestmt | declstmt | importstmt}

statement = [compileriden],
  ( ifstmt | 
	forstmt | 
	whilestmt | 
	switchstmt |
	returnstmt | 
	raisestmt | 
	gotostmt | 
	labelstmt |
	deferstmt |
	breakstmt |
	continuestmt | 
	leavestmt | 
	usingstmt |
	namespacestmt |
	declstmt | 
	assstmt |
	expressionstmt |
	scope )
	
(* Can replace a whole scope *)
scopestatement = 
  ( ifstmt |
	forstmt |
	whilestmt | 
	switchstmt | 
	returnstmt |
	raisestmt | 
	gotostmt | 
	breakstmt | 
	continuestmt | 
	leavestmt |
	assstmt | 
	expressionstmt |
	scope )

compileropts = dollar, obracket, compileriden, {comma, compileriden}, [comma], cbracket
scope = obrace, {statement}, cbrace, [compileropts]
	
ifstmt = cif, {fexpression, stmtend}, expression, (cdo, scopestatement | ifscope)
ifscope = scope, [celse, scopestatement]

forstmt = cfor, forcond, (cdo, scopestatement | scope)
(* Note: Written in not LL2 for clarity, easily convertible *)
forcond = 
  ( [fexpression], stmtend, [expression], stmtend, [mexpression] |
	(type | tlet), iden, optthen, expression |
	[type | tlet], iden, assop, expression, comma, expression, [comma, expression] )

whilestmt = cwhile, {fexpression, stmtend}, expression, (cdo, scopestatement | scope)

switchstmt = cswitch, {fexpression, stmtend}, expression, switchscope
switchscope = obrace, {casestmt}, cbrace
casestmt = (kwcase, expression, {comma, expression}, [comma] | celse), (ccontinue | scope | cdo, scopestatement)

returnstmt = creturn, [expression, {comma, expression}, [comma] | tvoid], stmtend

raisestmt = craise, expression, {comma, expression}, [comma], stmtend

gotostmt = cgoto, iden, stmtend

labelstmt = clabel, iden, stmtend

deferstmt = cdefer, expression, stmtend

breakstmt = cbreak, stmtend

continuestmt = ccontinue, stmtend

leavestmt = cleave, stmtend

importstmt = kwimport, (iden | string), [kwas, iden], stmtend

usingstmt = kwusing, iden, {opaccess, iden}, [kwas, iden], stmtend

namespacestmt = kwnamespace, iden, {opaccess, iden}, scope

varclass = {kwqualifier}, [kwsign]
type = (tbyte | tchar | tshort | tint | tlong | tsig | tfloat | tdouble | tbool | tstring | functype | iden), [spointer], {varclass, spointer}, {obracket, expression, cbracket}{obracket, cbracket}
functype = tfunction, [othan, type, {optthen, type}, oparen, [type, {comma, type}, [comma]], cparen, cthan]

declstmt = ( vardecl, {vardeclend, vardecl}, stmtend | funcdecl | structdecl | uniondecl | enumdecl )

declstructstmt = ( vardeclstruct, {vardeclend, vardeclstruct}, stmtend | funcdecl | structdecl | uniondecl | enumdecl )

vardecl = [varclass], (type | tlet), iden, {comma, [[varclass], type], iden}, [assop, aexpression, {comma, aexpression}]

vardeclstruct = [varclass], (type | tlet), iden, [optthen, number], {comma, [[varclass], type], iden, [optthen, number]}, [assop, aexpression, {comma, aexpression}]

funcdecl = (type, {optthen, type} | tvoid | tlet), iden, oparen, [parameter, {comma, parameter}, [comma]], cparen, (scope | stmtend)
parameter = type, [iden, [assop, aexpression]]

funcval = (type, {optthen, type} | tvoid | tlet), [iden], oparen, [parameter, {comma, parameter}, [comma]], cparen, scope

structdecl = tstruct, iden, structscope, [compileropts]
structscope = obrace, {usingstmt | declstructstmt}, cbrace

uniondecl = tunion, iden, unionscope, [compileropts]
unionscope = obrace, {usingstmt | declstmt}, cbrace

enumdecl = tenum, iden, enumscope, [compileropts]
enumscope = obrace, [iden, {comma, iden}, [comma]], cbrace


assstmt = assignment, stmtend
assignment = iden, {comma, iden}, assop, aexpression, {comma, aexpression}

expressionstmt = expression, stmtend
expression = e17

e17   = e16, [e17']
e17'  = optcond, e17, optthen, e17

e16   = e15, {e16'}
e16'  = (opequals | opnequals),  e15

e15   = e14, {e15'}
e15'  = (oplt | opleqt | opgt | opgeqt), e14

e14   = e13, {e14'}
e14'  = oplxor, e13

e13   = e12, {e13'}
e13'  = oplor, e12

e12   = e11, {e12'}
e12'  = opland, e11

e11   = e10, {e11'}
e11'  = opxor, e10

e10   = e9, {e10'}
e10'  = opor, e9

e9    = e8, {e9'}
e9'   = opand, e8

e8    = e7, {e8'}
e8'	  = (opbitset | opbitclear | opbitcheck | opbittoggle), e7

e7    = e6, {e7'}
e7'	  = (opbitshiftl | opbitshiftr | oprotatel | oprotater), e6

e6    = e5, {e6'}
e6'	  = (opadd | opsub | opconcat), e5

e5    = e4, {e5'}
e5'	  = (opmul | opdiv | opmod), e4

e4    = e3, [e4']
e4'   = (oppow | opconcat), e4

e3    = (opinc | opdec | opadd | opsub | opnot | oplnot | "<", type, ">" | opat | opaddress) e3 | e2

e2  = e1, {e2'}
e2' = (opspread)

e1    = ee, {e1'}
e1'	  = (opinc | opdec | "(", [argument, {",", argument}], ")" | "[", expression, "]" | opaccess, iden), {opinc | opdec | "(", [argument, {",", argument}], ")" | "[", expression, "]" | opaccess, iden}, ee

ee 	  = "(", (expression | functionval), ")" | literal | iden

argument = aexpression | iden, "=", aexpression
fexpression = expression | vardecl | assignment
mexpression = expression | assignment
aexpression = (expression | snothing | funcval)