Registers:
16 general purpose registers, r0-r15.
16 floating point registers, f0-f15.
Program counter, pc.
Status flag register, sf.
Stack pointer register, sp.
Stack frame pointer, fp.
Each register is 64 bits long.

Program counter is updated before each instruction is run.
Status flags:
 0 : Zero flag. Previous arithmetic operation resulted in zero.
 1 : Check flag. Previous check operation passed.

All instructions and operands are aligned in memory to their size.
Instructions: At least 2 bytes, at most 62 bytes.
Iden: 2 bytes opcode. 
Operand: 
 - Register: 1 byte register number.
 - Memory: 1 bit location type. 2 bits offset type. 5 bits empty. 1 or 8 bytes for location. 0, 1 or 8 bytes for offset. 2, 3, 16 or 17 bytes in total. (If two immediates are given they are optimized to a single immadiate)
 - Immediate: 1,2, 4 or 8 bytes immediate.

Registers, values and memory locations can be preceded by one of the following type specifiers: u8, u16, u32, u64, s8, s16, s32, s64, f32, f64. The default if none is specified is u64. 
<reg> = Any register. 1 byte. Preceeded by $.
<val> = Any value. 8 bytes. 
        Numbers can be given in decimal, hexadecimal (0x), octal (0o) or binary (0b) form.
Registers and values can be encased in brackets to take the value at that address.
Registers dereferenced this way may have an offset given by (+|-)number.
<idn> = An identifier. No quotes.
<x,y> = x or y.
<any> = Anything.
<>? = Optional operand.
<:x> = Of type x.
<:!> = This op determines the type of the others.
<:?> = This op's type is predetermined by a previous op's type.
@opx: Memory location pointed at by opx.

- Types:
 - u: u8 | u16 | u32 | u64.
 - s: s8 | s16 | s32 | s64.
 - f: f32 | f64.
 - i: u | s.
 - a: i | f.
 - nu: s | f.
 - ns: u | f.
 - nf32: i | f64.
 - nf64: i | f32.

~~ General ~~
General instructions.
NOP - No operation.
LOAD <any:u> <reg:a> - Copy value of @op1 to op2.
STOR <reg:a> <any:u> - Copy value of op1 to @op2.
MOV <any:a!> <reg:a?> - Copy value of op1 to op2.
CPY <any:u> <any:u> <any:u> - Copy op3 bytes from @op1 to @op2.
ZRO <any:u> <any:u> - Zero op2 bytes at @op1. 
SET <any:u8> <any:u> <any:u> - Set op3 bytes at @op2 to value op1.
BRK - Break and jump to debugger.
HLT - Stops the program.

~~ Comparisons and checks ~~
Comparison and check instructions. S means the comparison is signed.
CZRO <any:a> - Sets check flag if op1 is zero.
CNZR <any:a> - Sets check flag if op1 is not zero.
CEQ <any:a!> <any:a?> - Sets check flag if op1 equals op2.
CNEQ <any:a!> <any:a?> - Sets check flag if op1 does not equal op2.
CBS <any:u> <any:u8> - Sets check flag if bit op2 is set in op1.
CBNS <any:u> <any:u8> - Sets check flag if bit op2 is not set in op1.

CLT <any:a!> <any:a?> - Sets check flag if op1 is less than op2.
CLE <any:a!> <any:a?> - Sets check flag if op1 is less or equal to op2.
CGT <any:a!> <any:a?> - Sets check flag if op1 is greater than op2.
CGE <any:a!> <any:a?> - Sets check flag if op1 is greater or equal to op2.

~~ Flow control ~~
Instructions to jump around the program.
JMP <any:u> - Copy value of op1 to program counter.
JMPR <any:i> - Jump to pc + op1.
JCH <any:u> - Jump to op1 if check flag is set.
JNCH <any:u> - Jump to op1 if check flag is not set.

~~ Stack ~~
PUSH <any:a> - Push op1 onto the stack, move the stack pointer up by size of op1.
PUSH <any:u> <any:u> - Push op2 bytes from @op1 onto the stack, move the stack pointer up by op2.
POP <val:u> - Move the stack pointer down by op1 bytes.
POP <reg:a> - Pop size of op1 bytes to op1. Move stack pointer size of op1 bytes.
BTIN <any:u> - Call builtin function op1. Pushes call pc onto stack.
CALL <any:u> - Call function at location op1. Pushes call pc onto stack.
CALL <any:u> <any:u> - Call function at location op1 with op2 bytes of parameters.
RET - Return from function. Pops from the stack to pc.

~~ Casting ~~
Instructions to perform casting.
CASTU <any:nu> <reg:u> - Cast op1 to unsigned and store in op2.
CASTS <any:ns> <reg:s> - Cast op1 to signed and store in op2.
CASTF <any:nf32> <reg:f32> - Cast op1 to float and store in op2.
CASTD <any:nf64> <reg:f64> - Cast op1 to double and store in op2.

~~ Arithmetic and bit manip ~~
Instructions to perform arithmetic and bit manipulation.

ADD <any:a!> <reg:a?> - Add op1 and op2. Store in op2.
ADD <any:a!> <any:a?> <reg:a?> - Add op1 and op2. Store in op3.
INC <reg:i> - Increment op1.
INC <any:i!> <reg:i?> - Increment op1. Store in op2.
SUB <any:a!> <reg:a?> - Subtract op1 from op2. Store in op2.
SUB <any:a!> <any:a?> <reg:a?>- Subtract op1 from op2. Store in op2.
DEC <reg:i> - Decrement op1.
DEC <any:i!> <reg:i?> - Decrement op1. Store in op2.
MUL <any:a!> <reg:a?> - Multiply op1 and op2. Store in op2.
MUL <any:a!> <any:a!> <reg:a?> - Multiply op1 and op2. Store in op3.
DIV <any:a!> <reg:a?> - Divide op2 by op1. Store in op2.
DIV <any:a!> <any:a!> <reg:a?> - Divide op2 by op1. Store in op3.
MOD <any:i!> <reg:i?> - Divide op2 and op1. Store remainder in op2.
MOD <any:i!> <any:i?> <reg:i?> - Divide op2 and op1. Store remainder in op3.
ABS <reg:s> - Get absolute value of op1. Store in unsigned op1.
ABS <reg:f> - Get absolute value of op1. Store in op1.
ABS <any:s> <reg:u> - Get absolute value of op1. Store in op2.
ABS <any:f!> <reg:f?> - Get absolute value of op1. Store in op2.
NEG <reg:u> - Get negative of op1. Store in signed op1.
NEG <reg:nu> - Get negative of op1. Store in op1.
NEG <any:u> <reg:s> - Get negative of op1. Store in op2.
NEG <any:nu!> <reg:nu?> - Get negative of op1. Store in op2.
SHR <any:u8> <reg:i> - Shift op2 right by op1. Store in op2.
SHR <any:u8> <any:i!> <reg:i?> - Shift op2 right by op1. Store in op3.
SHL <any:u8> <reg:i> - Shift op2 left by op1. Store in op2.
SHL <any:u8> <any:i!> <reg:i?> - Shift op2 left by op1. Store in op3.
RTR <any:u8> <reg:u> - Rotate op2 right by op1. Store in op2.
RTR <any:u8> <any:u!> <reg:u?> - Rotate op2 right by op1. Store in op3.
RTL <any:u8> <reg:u> - Rotate op2 left by op1. Store in op2.
RTL <any:u8> <any:u!> <reg:u?> - Rotate op2 left by op1. Store in op3.
AND <any:u!> <reg:u?> - And op1 and op2. Store in op2.
AND <any:u!> <any:u?> <reg:u?> - And op1 and op2. Store in op3.
OR  <any:u!> <reg:u?> - Or op1 and op2. Store in op2.
OR  <any:u!> <any:u?> <reg:u?> - Or op1 and op2. Store in op2.
XOR <any:u!> <reg:u?> - Xor op1 and op2. Store in op2.
XOR <any:u!> <any:u?> <reg:u?> - Xor op1 and op2. Store in op2.
NOT <reg:u> - Not op1. Store in op1.
NOT <any:u!> <reg:u?> - Not op1. Store in op2.

~~ Pseudoinstructions ~~
VAL <idn> <val> - Create internal value op2 with name op1. Can be used anywhere, preceded by <.
DB <idn> <val>... - Statically store value op2... with name op1. Used as an address. Can be preceeded by ~ to get size and be used as a value.
DBS <idn> <val>... - Statically store string value op2... with name op1. Used as an address. Can be preceeded by ~ to get size and be used as a value.
LBL <idn> - Create label with name op1.