Registers:
16 general purpose registers, r1-r16.
16 floating point registers, f1-f16.
Program counter, pc or r17.
Status flag register, sf or r18.
Stack pointer register, sp or r19.
Each register is 64 bits long.

Program counter is updated before each instruction is run.
Status flags:
 0 : Zero flag. Previous arithmetic operation resulted in zero.
 1 : Check flag. Previous check operation passed.

Instructions: At least 2 bytes, at most 32 bytes.
Iden: 8 bits opcode. 2 bits operands. 6 bits operand types. 
Operand: 
 - Register: 1 bit floating. 2 bits length. 5 bits register number.
 - Memory: 1 bit location type. 2 bits length. 2 bits displacement type. 2 bits displacement size. 1 bit displacement signed. 1-8 bytes location. 1-8 bytes displacement. 2-9 bytes total for displacement + location.
 - Immediate: 2 bits length. 6 bits empty. 1-8 bytes immediate.

Registers, values and memory locations can be preceded by one of the following type specifiers: u8, u16, u32, u64, s8, s16, s32, s64, f32, f64. The default if none is specified is u64.
<reg> = Any register. 1 byte. Preceeded by $.
<val> = Any value. 8 bytes. 
        Numbers can be given in decimal, hexadecimal (0x), octal (0o) or binary (0b) form.
Registers and values can be encased in brackets to take the value at that address w
ith that size. These will always be taken as u64.
Registers dereferenced this way may have an offset given by (+|-)number.
<idn> = An identifier. No quotes.
<x,y> = x or y.
<any> = Anything.
<:x> = Exactly x bytes.
<:x+> = x or more bytes.
<:x-> = x or less bytes.
@opx: Memory location pointed at by opx.

~~ General ~~
General instructions.
NOP - No operation.
LOAD <any> <reg> - Copy value of @op1 to op2.
STOR <reg> <any> - Copy value of op1 to @op2.
MOV <any> <reg> - Copy value of op1 to op2.
CPY <any> <any> <any> - Copy op3 bytes from @op1 to @op2.
ZRO - <any> <any> - Zero op2 bytes at @op1. 
SET - <any:1> <any> <any> - Set op3 bytes at @op2 to value op1.
BRK - Break and jump to debugger.
HLT - Stops the program.

~~ Comparisons and checks ~~
Comparison and check instructions. S means the comparison is signed. 
Prefixed with [SFD] for signed, float and double versions.
CZRO <any> - Sets check flag if op1 is zero.
CNZR <any> - Sets check flag if op1 is not zero.
CEQ <any> <any> - Sets check flag if op1 equals op2.
CNEQ <any> <any> - Sets check flag if op1 does not equal op2.
CBS <any> <any:1> - Sets check flag if bit op2 is set in op1.
CBNS <any> <any:1> - Sets check flag if bit op2 is not set in op1.

[SFD]CLT <any> <any> - Sets check flag if op1 is less than op2.
[SFD]CLE <any> <any> - Sets check flag if op1 is less or equal to op2.
[SFD]CGT <any> <any> - Sets check flag if op1 is greater than op2.
[SFD]CGE <any> <any> - Sets check flag if op1 is greater or equal to op2.

~~ Flow control ~~
Instructions to jump around the program.
JMP <any> - Copy value of op1 to program counter.
[S]JMPR <any> - Jump to pc + op1.
JCH <any> - Jump to op1 if check flag is set.
JNCH <any> - Jump to op1 if check flag is not set.

~~ Stack ~~
PUSH <any> - Push op1 onto the stack, move the stack pointer up by size of op1.
PUSH <any> <any> - Push op2 bytes from @op1 onto the stack, move the stack pointer up by op2.
POP <val> - Move the stack pointer down by op1 bytes.
POP <reg> - Pop size of op1 bytes to op1. Move stack pointer size of op1 bytes.
BTIN <any> - Call builtin function op1. Pushes call pc onto stack.
CALL <any> - Call function at location op1. Pushes call pc onto stack.
RET - Return from function. Pops from the stack to pc.

~~ Casting ~~
Instructions to perform casting.
They all have a version with an extra parameter where the result is stored, instead of overwriting.
CSTU <any> - Cast op1 from signed to unsigned.
CSTF <any> - Cast op1 from signed to float.
CSTD <any> - Cast op1 from signed to double.
CUTS <any> - Cast op1 from unsigned to signed.
CUTF <any> - Cast op1 from unsiged to float.
CUTD <any> - Cast op1 from unsigned to double.
CFTS <any> - Cast op1 from float to signed.
CFTU <any> - Cast op1 from float to unsigned.
CFTD <any> - Cast op1 from float to double.
CDTS <any> - Cast op1 from double to signed.
CDTU <any> - Cast op1 from double to unsigned.
CDTF <any> - Cast op1 from double to float.

~~ Arithmetic and bit manip ~~
Instructions to perform arithmetic and bit manipulation. 
They all have a version with an extra reg parameter where the result is stored, instead of overwriting.
Prefixed with [SFD] for signed, float and double versions.

[SFD]ADD <any> <reg> - Add op1 and op2. Store in op2.
[S]INC <reg> - Increment op1.
[SFD]SUB <any> <reg> - Subtract op1 from op2. Store in op2.
[S]DEC <reg> - Decrement op1.
[SFD]MUL <any> <reg> - Multiply op1 and op2. Store in op2.
[SFD]DIV <any> <reg> - Divide op2 by op1. Store in op2.
[S]MOD <any> <reg> - Divide op2 and op1. Store remainder in op2.
[SFD]ABS <reg> - Get absolute value of op1. Store in op1. Note that ABS does not have an unsigned version.
[SFD]NEG <reg> - Get negative of op1. Store in op1. Note that NEG does not have an unsigned version.
[S]SHR <any:1> <reg> - Shift op2 right by op1. Store in op2.
[S]SHL <any:1> <reg> - Shift op2 left by op1. Store in op2.
RTR <any:1> <reg> - Rotate op2 right by op1. Store in op2.
RTL <any:1> <reg> - Rotate op2 left by op1. Store in op2.
AND <any> <reg> - And op1 and op2. Store in op2.
OR  <any> <reg> - Or op1 and op2. Store in op2.
XOR <any> <reg> - Xor op1 and op2. Store in op2.
NOT <reg> - Not op1. Store in op1.

~~ Pseudoinstructions ~~
VAL <idn> <val> - Create internal value op2 with name op1. Can be used anywhere, preceded by <.
DB <idn> <val>... - Statically store value op2... with name op1. Used as an address. Can be preceeded by ~ to get size and be used as a value.
DBS <idn> <val>... - Statically store string value op2... with name op1. Used as an address. Can be preceeded by ~ to get size and be used as a value.
LBL <idn> - Create label with name op1.