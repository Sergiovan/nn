+ NOP {%
    /* No op */
%} # No operation.
+ LOAD <any:u> <reg:a> {%
    u8* from = memory + op1;
    if (!check(from, (u64) sizeof(t1))) {
        trap(vmtraps::illegal_read);
        return;
    }
    op2 = *reinterpret_cast<t2*>(from);
%} # Copy value of @op1 to op2.
+ STOR <reg:a> <any:u> {%
    u8* to = memory + op2;
    if (!check(to, (u64) sizeof(t2))) {
        trap(vmtraps::illegal_write);
        return;
    }
    *reinterpret_cast<t1*>(to) = op1;
%} # Copy value of op1 to @op2.
+ MOV <any:a!> <reg:a?> {%
    op2 = op1;
%} # Copy value of op1 to op2.
+ CPY <any:u> <any:u> <any:u> {%
    u8* from = memory + op1;
    u8* to = memory + op2;
    if (!check(from, (u64) op3)) {
        trap(vmtraps::illegal_read);
        return;
    }
    if (!check(to, (u64) op3)) {
        trap(vmtraps::illegal_write);
        return;
    }
    if ((from > to && from + op3 > to) || (to > from && to + op3 > from)) {
        std::memmove(to, from, op3);
    } else {
        std::memcpy(to, from, op3);
    }
%} # Copy op3 bytes from @op1 to @op2.
+ ZRO <any:u> <any:u> {%
    u8* from = memory + op1;
    if (!check(from, (u64) op2)) {
        trap(vmtraps::illegal_write);
        return;
    }
    std::memset(from, 0, op2);
%} # Zero op2 bytes at @op1. 
+ SET <any:u8> <any:u> <any:u> {%
    u8* from = memory + op2;
    if (!check(from, (u64) op3)) {
        trap(vmtraps::illegal_write);
        return;
    }
    std::memset(from, op1, op3);
%} # Set op3 bytes at @op2 to value op1.
+ BRK {%
    trap(vmtraps::break_trap);
    pause();
%} # Break and jump to debugger.
+ HLT {%
    trap(vmtraps::halt);
    stop();
%} # Stops the program.
+ CZRO <any:a> {%
    sf.check = (op1 == 0);
%} # Sets check flag if op1 is zero.
+ CNZR <any:a> {%
    sf.check = (op1 != 0);
%} # Sets check flag if op1 is not zero.
+ CEQ <any:a!> <any:a?> {%
    sf.check = (op1 == op2);
%} # Sets check flag if op1 equals op2.
+ CNEQ <any:a!> <any:a?> {%
    sf.check = (op1 != op2);
%} # Sets check flag if op1 does not equal op2.
+ CBS <any:u> <any:u8> {%
    sf.check = (op1 & (1 << op2));
%} # Sets check flag if bit op2 is set in op1.
+ CBNS <any:u> <any:u8> {%
    sf.check = !(op1 & (1 << op2));
%} # Sets check flag if bit op2 is not set in op1.
+ CLT <any:a!> <any:a?> {%
    sf.check = (op1 < op2);
%} # Sets check flag if op1 is less than op2.
+ CLE <any:a!> <any:a?> {%
    sf.check = (op1 <= op2);
%} # Sets check flag if op1 is less or equal to op2.
+ CGT <any:a!> <any:a?> {%
    sf.check = (op1 > op2);
%} # Sets check flag if op1 is greater than op2.
+ CGE <any:a!> <any:a?> {%
    sf.check = (op1 >= op2);
%} # Sets check flag if op1 is greater or equal to op2.
+ JMP <any:u> {%
    if (!check_jump(memory + op1)) {
        trap(vmtraps::illegal_jump);
        return;
    }
    pc._u64 = op1;
%} # Copy value of op1 to program counter.
+ JMPR <any:i> {%
    if (!check_jump(memory + (pc._u64 + op1))) {
        trap(vmtraps::illegal_jump);
        return;
    }
    pc._u64 += op1;
%} # Jump to pc + op1.
+ JCH <any:u> {%
    if (!sf.check) return;
    if (!check_jump(memory + op1)) {
        trap(vmtraps::illegal_jump);
        return;
    }
    pc._u64 = op1;
%} # Jump to op1 if check flag is set.
+ JNCH <any:u> {%
    if (sf.check) return;
    if (!check_jump(memory + op1)) {
        trap(vmtraps::illegal_jump);
        return;
    }
    pc._u64 = op1;
%} # Jump to op1 if check flag is not set.
+ PUSH <any:a> {%
    if (sp._u64 - sizeof(t1) < allocated - stack_size) {
        trap(vmtraps::stack_overflow);
        return;
    }
    sp._u64 -= sizeof(t1);
    *reinterpret_cast<t1*>(memory + sp._u64) = op1;
%} # Push op1 onto the stack, move the stack pointer up by size of op1.
+ PUSH <any:u> <any:u> {%
    u8* from = memory + op1;
    if (sp._u64 - op2 < allocated - stack_size) {
        trap(vmtraps::stack_overflow);
        return;
    }
    if (!check(from, (u64) op2)) {
        trap(vmtraps::illegal_read);
        return;
    }
    sp._u64 -= op2;
    std::memcpy(memory + sp._u64, from, op2);
%} # Push op2 bytes from @op1 onto the stack, move the stack pointer up by op2.
+ POP <val:u> {%
    if (sp._u64 + op1 > allocated) {
        trap(vmtraps::stack_underflow);
        return;
    }
    sp._u64 += op1;
%} # Move the stack pointer down by op1 bytes.
+ POP <reg:a> {%
    if (sp._u64 + sizeof(t1) > allocated) {
        trap(vmtraps::stack_underflow);
        return;
    }
    op1 = *reinterpret_cast<t1*>(memory + sp._u64);
    sp._u64 += sizeof(t1);
%} # Pop size of op1 bytes to op1. Move stack pointer size of op1 bytes.
+ BTIN <any:u> {%
    (void) op1;
    trap(vmtraps::illegal_btin); // Oops
%} # Call builtin function op1. Pushes call pc onto stack.
+ CALL <any:u> {%
    if (!check_jump(memory + op1)) {
        trap(vmtraps::illegal_jump);
        return;
    }
    if (sp._u64 - sizeof(u64) * 2 < allocated - stack_size) {
        trap(vmtraps::stack_overflow);
        return;
    }
    *reinterpret_cast<u64*>(memory + sp._u64 - sizeof(u64)) = fp._u64;
    *reinterpret_cast<u64*>(memory + sp._u64 - sizeof(u64) * 2) = pc._u64;
    sp._u64 -= sizeof(u64) * 2;
    pc._u64 = op1;
%} # Call function at location op1. Pushes call pc onto stack.
+ RET {%
    if (sp._u64 + sizeof(u64) * 2 > allocated) {
        trap(vmtraps::stack_underflow);
        return;
    }
    pc._u64 = *reinterpret_cast<u64*>(memory + sp._u64);
    fp._u64 = *reinterpret_cast<u64*>(memory + sp._u64 + sizeof(u64));
    sp._u64 += sizeof(u64) * 2;
%} # Return from function. Pops from the stack to pc.
+ CASTU <any:nu> <reg:u> {%
    op2 = (t2) op1;
%} # Cast op1 to unsigned and store in op2.
+ CASTS <any:ns> <reg:s> {%
    op2 = (t2) op1;
%} # Cast op1 to signed and store in op2.
+ CASTF <any:nf32> <reg:f32> {%
    op2 = (t2) op1;
%} # Cast op1 to float and store in op2.
+ CASTD <any:nf64> <reg:f64> {%
    op2 = (t2) op1;
%} # Cast op1 to double and store in op2.
+ ADD <any:a!> <reg:a?> {%
    sf.zero = !(op2 += op1);
%} # Add op1 and op2. Store in op2.
+ ADD <any:a!> <any:a?> <reg:a?> {%
    sf.zero = !(op3 = op1 + op2);
%} # Add op1 and op2. Store in op3.
+ INC <reg:i> {%
    sf.zero = !(++op1);
%} # Increment op1.
+ INC <any:i!> <reg:i?> {%
    sf.zero = !(op2 = op1 + 1);
%} # Increment op1. Store in op2.
+ SUB <any:a!> <reg:a?> {%
    sf.zero = !(op2 -= op1);
%} # Subtract op1 from op2. Store in op2.
+ SUB <any:a!> <any:a?> <reg:a?> {%
    sf.zero = !(op3 = op2 - op1);
%} # Subtract op1 from op2. Store in op2.
+ DEC <reg:i> {%
    sf.zero = !(--op1);
%} # Decrement op1.
+ DEC <any:i!> <reg:i?> {%
    sf.zero = !(op2 = op1 - 1);
%} # Decrement op1. Store in op2.
+ MUL <any:a!> <reg:a?> {%
    sf.zero = !(op2 *= op1);
%} # Multiply op1 and op2. Store in op2.
+ MUL <any:a!> <any:a?> <reg:a?> {%
    sf.zero = !(op3 = op1 * op2);
%} # Multiply op1 and op2. Store in op3.
+ DIV <any:a!> <reg:a?> {%
    sf.zero = !(op2 /= op1);
%} # Divide op2 by op1. Store in op2.
+ DIV <any:a!> <any:a?> <reg:a?> {%
    sf.zero = !(op3 = op2 / op1);
%} # Divide op2 by op1. Store in op3.
+ MOD <any:i!> <reg:i?> {%
    sf.zero = !(op2 %= op1);
%} # Divide op2 and op1. Store remainder in op2.
+ MOD <any:i!> <any:i?> <reg:i?> {%
    sf.zero = !(op3 = op2 % op1);
%} # Divide op2 and op1. Store remainder in op3.
+ ABS <reg:s> {%
    sf.zero = !(op1 = std::abs(op1));
%} # Get absolute value of op1. Store in unsigned op1.
+ ABS <reg:f> {%
    sf.zero = !(op1 = std::abs(op1));
%} # Get absolute value of op1. Store in op1.
+ ABS <any:s8> <reg:u8> {%
    sf.zero = !(op2 = std::abs(op1));
%} # Get absolute value of op1. Store in op2.
+ ABS <any:s16> <reg:u16> {%
    sf.zero = !(op2 = std::abs(op1));
%} # Get absolute value of op1. Store in op2.
+ ABS <any:s32> <reg:u32> {%
    sf.zero = !(op2 = std::abs(op1));
%} # Get absolute value of op1. Store in op2.
+ ABS <any:s64> <reg:u64> {%
    sf.zero = !(op2 = std::abs(op1));
%} # Get absolute value of op1. Store in op2.
+ ABS <any:f!> <reg:f?> {%
    sf.zero = !(op2 = std::abs(op1));
%} # Get absolute value of op1. Store in op2.
+ NEG <reg:nu> {%
    sf.zero = !(op1 = -op1);
%} # Get negative of op1. Store in op1.
+ NEG <any:u8> <reg:s8> {%
    sf.zero = !(op2 = -op1);
%} # Get negative of op1. Store in op2.
+ NEG <any:u16> <reg:s16> {%
    sf.zero = !(op2 = -op1);
%} # Get negative of op1. Store in op2.
+ NEG <any:u32> <reg:s32> {%
    sf.zero = !(op2 = -op1);
%} # Get negative of op1. Store in op2.
+ NEG <any:u64> <reg:s64> {%
    sf.zero = !(op2 = -op1);
%} # Get negative of op1. Store in op2.
+ NEG <any:nu!> <reg:a?> {%
    sf.zero = !(op2 = -op1);
%} # Get negative of op1. Store in op2.
+ SHR <any:u8> <reg:i> {%
    sf.zero = !(op2 >>= op1);
%} # Shift op2 right by op1. Store in op2.
+ SHR <any:u8> <any:i!> <reg:i?> {%
    sf.zero = !(op3 = op2 >> op1);
%} # Shift op2 right by op1. Store in op3.
+ SHL <any:u8> <reg:i> {%
    sf.zero = !(op2 <<= op1);
%} # Shift op2 left by op1. Store in op2.
+ SHL <any:u8> <any:i!> <reg:i?> {%
    sf.zero = !(op3 = op2 << op1);
%} # Shift op2 left by op1. Store in op3.
+ RTR <any:u8> <reg:u> {%
    sf.zero = !(op2 = ((op2 >> op1) | (op2 << (sizeof(t2) - op1))));
%} # Rotate op2 right by op1. Store in op2.
+ RTR <any:u8> <any:u!> <reg:u?> {%
    sf.zero = !(op3 = ((op2 >> op1) | (op2 << (sizeof(t2) - op1))));
%} # Rotate op2 right by op1. Store in op3.
+ RTL <any:u8> <reg:u> {%
    sf.zero = !(op2 = ((op2 << op1) | (op2 >> (sizeof(t2) - op1))));
%} # Rotate op2 left by op1. Store in op2.
+ RTL <any:u8> <any:u!> <reg:u?> {%
    sf.zero = !(op3 = ((op2 << op1) | (op2 >> (sizeof(t2) - op1))));
%} # Rotate op2 left by op1. Store in op3.
+ AND <any:u!> <reg:u?> {%
    sf.zero = !(op2 &= op1);
%} # And op1 and op2. Store in op2.
+ AND <any:u!> <any:u?> <reg:u?> {%
    sf.zero = !(op3 = op2 & op1);
%} # And op1 and op2. Store in op3.
+ OR  <any:u!> <reg:u?> {%
    sf.zero = !(op2 |= op1);
%} # Or op1 and op2. Store in op2.
+ OR  <any:u!> <any:u?> <reg:u?> {%
    sf.zero = !(op3 = op2 | op1);
%} # Or op1 and op2. Store in op2.
+ XOR <any:u!> <reg:u?> {%
    sf.zero = !(op2 ^= op1);
%} # Xor op1 and op2. Store in op2.
+ XOR <any:u!> <any:u?> <reg:u?> {%
    sf.zero = !(op3 = op2 ^ op1);
%} # Xor op1 and op2. Store in op2.
+ NOT <reg:u> {%
    sf.zero = !(op1 = ~op1);
%} # Not op1. Store in op1.
+ NOT <any:u!> <reg:u?> {%
    sf.zero = !(op2 = ~op1);
%} # Not op1. Store in op2.

- VAL <idn> <val> - Create internal value op2 with name op1. Can be used anywhere, preceded by <.
- DB <idn> <val>... - Statically store value op2... with name op1. Used as an address. Can be preceeded by ~ to get size and be used as a value.
- DBS <idn> <val>... - Statically store string value op2... with name op1. Used as an address. Can be preceeded by ~ to get size and be used as a value.
- LBL <idn> - Create label with name op1.
